#!/usr/bin/env python3
# Copyright (c) 2009, Karoly Lorentey  <karoly@lorentey.hu>

import sys
import codecs
import locale
import warnings
from optparse import OptionParser, OptionGroup

import stagger
import stagger.fileutil
from stagger.id3 import *

# Work around idiotical python encoding heuristics:
# Use locale-specified encoding on both stdout and stderr,
# regardless of whether they are ttys
sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout.buffer)
sys.stderr = codecs.getwriter(locale.getpreferredencoding())(sys.stderr.buffer)

versionstr = ".".join((str(v) for v in stagger.version))

parser = OptionParser(usage="%prog [options] file1.mp3 [file2.mp3...]",
                      version="%prog " + versionstr)

parser.add_option("-q", "--quiet", action="store_true", dest="quiet",
                  help="Suppress warning messages on stderr")

group = OptionGroup(parser, "Commands")
group.add_option("-p", "--print", action="store_true", dest="print",
                 help="(default) Print tags")
group.add_option("-d", "--delete", action="store_true", dest="delete",
                  help="Delete tags")
parser.add_option_group(group)

group = OptionGroup(parser, "Low-level options")
group.add_option("-l", "--low", 
                 action="store_true", dest="low",
                 help="Print low-level frame ids "
                 "instead of descriptive names")

group.add_option("--dump",
                 action="store", dest="dump", metavar="FILE",
                 help="Dump raw binary tag from FILE to stdout")

group.add_option("--load",
                 action="store", dest="load", metavar="FILE",
                 help="Load binary tag dump from stdin and apply to FILE")

group.add_option("--stats",
                 action="store_true", dest="stats",
                 help="Print resource usage statistics to stderr before exiting")

parser.add_option_group(group)

(options, args) = parser.parse_args()

def dump_tag(filename):
    with open(filename, "rb") as file:
        try:
            (cls, offset, length) = stagger.tags.detect_tag(file)
        except stagger.NoTagError:
            return bytes()
        file.seek(offset)
        return file.read(length)

def load_tag(filename, data):
    with open(filename, "rb+") as file:
        try:
            (cls, offset, length) = stagger.tags.detect_tag(file)
        except stagger.NoTagError:
            (offset, length) = (0, 0)
        stagger.fileutil.replace_chunk(file, offset, length, data)
    
def print_stats():
    try:
        import resource
        usage = resource.getrusage(resource.RUSAGE_SELF)
        print("utime={0}".format(usage.ru_utime), file=sys.stderr)
        print("stime={0}".format(usage.ru_stime), file=sys.stderr)
        print("maxrss={0}".format(usage.ru_maxrss), file=sys.stderr)
        print("ixrss={0}".format(usage.ru_ixrss), file=sys.stderr)
        print("page_faults={0}".format(usage.ru_majflt), file=sys.stderr)
        print("block_input={0}".format(usage.ru_inblock), file=sys.stderr)
        print("block_output={0}".format(usage.ru_oublock), file=sys.stderr)
    except (ImportError, AttributeError, ValueError):
        pass

if options.dump:
    if len(args) != 1:
        parser.error("--dump requires a single file argument")
        exit(1)
    sys.stdout.stream.write(dump_tag(args[0]))

elif options.load:
    if len(args) != 1:
        parser.error("--load requires a single file argument")
        exit(1)
    data = sys.stdin.buffer.read()
    if not data.startswith(b"ID3"):
        parser.error("invalid tag data")
        exit(1)
    load_tag(args[0], data)

elif options.delete:
    for filename in args:
        stagger.delete_tag(filename)

else: # print
    for filename in args:
        with warnings.catch_warnings(record=True) as ws:
            tag = None
            try:
                tag = stagger.read_tag(filename)
                print(filename + ": " + str(tag))
                sys.stdout.flush()
            except stagger.NoTagError:
                print(filename + ":error: No tag", file=sys.stderr)
            except stagger.Error as e:
                print(filename + ":error: " + ", ".join(e.args[0]), 
                      file=sys.stderr)
                if not options.quiet and len(ws) > 0:
                    for w in ws:
                        print(filename + ":warning: " + str(w.message), 
                              file=sys.stderr)
                sys.stderr.flush()
                if tag:
                    for frame in tag.frames():
                        print("   " + str(frame))
                    print()
                sys.stdout.flush()

if options.stats:
    print_stats()

exit(0)

#!/usr/bin/env python3
# Copyright (c) 2009, Karoly Lorentey  <karoly@lorentey.hu>

import sys
import codecs
import locale
import warnings
from optparse import OptionParser, OptionGroup

import stagger
import stagger.fileutil
from stagger.id3 import *

# Work around idiotical python encoding heuristics:
# Use locale-specified encoding on both stdout and stderr,
# regardless of whether they are ttys
sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout.buffer)
sys.stderr = codecs.getwriter(locale.getpreferredencoding())(sys.stderr.buffer)

versionstr = ".".join((str(v) for v in stagger.version))

parser = OptionParser(usage="%prog [options] file1.mp3 [file2.mp3...]",
                      version="%prog " + versionstr)

parser.add_option("-q", "--quiet", action="store_true", dest="quiet",
                  help="Suppress warning messages on stderr")

group = OptionGroup(parser, "Commands")
group.add_option("-p", "--print", action="store_true", dest="print",
                 help="(default) Print tags")
group.add_option("-d", "--delete", action="store_true", dest="delete",
                  help="Delete tags")
parser.add_option_group(group)

group = OptionGroup(parser, "Low-level options")
group.add_option("-l", "--low", 
                 action="store_true", dest="low",
                 help="Print low-level frame ids "
                 "instead of descriptive names")

group.add_option("--dump",
                 action="store", dest="dump", metavar="FILE",
                 help="Dump raw binary tag from FILE to stdout")

group.add_option("--load",
                 action="store", dest="load", metavar="FILE",
                 help="Load binary tag dump from stdin and apply to FILE")
parser.add_option_group(group)

(options, args) = parser.parse_args()

def dump_tag(filename):
    with open(filename, "rb") as file:
        try:
            (cls, offset, length) = stagger.tags.detect_tag(file)
        except stagger.NoTagError:
            return bytes()
        file.seek(offset)
        return file.read(length)

def load_tag(filename, data):
    with open(filename, "rb+") as file:
        try:
            (cls, offset, length) = stagger.tags.detect_tag(file)
        except stagger.NoTagError:
            (offset, length) = (0, 0)
        stagger.fileutil.replace_chunk(file, offset, length, data)
    
if options.dump:
    if len(args) != 1:
        parser.error("--dump requires a single file argument")
        exit(1)
    sys.stdout.stream.write(dump_tag(args[0]))
    exit(0)

if options.load:
    if len(args) != 1:
        parser.error("--load requires a single file argument")
        exit(1)
    data = sys.stdin.buffer.read()
    if not data.startswith(b"ID3"):
        parser.error("invalid tag data")
        exit(1)
    load_tag(args[0], data)
    exit(0)

if options.delete:
    for filename in args:
        stagger.delete_tag(filename)
    exit(0)

for filename in args:
    with warnings.catch_warnings(record=True) as ws:
        tag = None
        try:
            tag = stagger.read_tag(filename)
            print(filename + ": " + str(tag))
            sys.stdout.flush()
        except stagger.NoTagError:
            print(filename + ":error: No tag", file=sys.stderr)
        except stagger.Error as e:
            print(filename + ":error: " + ", ".join(e.args[0]), file=sys.stderr)
        if not options.quiet and len(ws) > 0:
            for w in ws:
                print(filename + ":warning: " + str(w.message), file=sys.stderr)
        sys.stderr.flush()
        if tag:
            for frame in tag.frames():
                print("   " + str(frame))
        print()
        sys.stdout.flush()
